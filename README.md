# Linux课程设计

### 设计要求

- 软件包含前、后台两个程序，用户启动前台程序时，前台程序自行启动后台程序。前台程序提供界面，负责接收用户输入，对输入进行转换，并向后台程序发出实际要执行的指令，后台负责执行实际的指令。

- 前台程序通过fork和execl系统调用启动后台程序。
- 前台程序创建消息队列和命名管道，通过消息队列向后台程序发送经过转换的用户命令；通过命名管道从后台程序获取命令执行的结果，并显示在终端。后台程序可以通过popen来执行转换后的命令。
- 至少实现如下Windows——Linux对照命令：dir——ls，rename——mv，move——mv，del——rm，cd——cd（pwd），exit——exit。
- 当用户输入exit时，前台程序指示后台程序结束，在后台程序结束后，前台程序退出；在此之前，用户的输入都被作为一条命令进行处理。

---

### 一些知识点

```c
pid_t wait(int *status):
进程一旦调用wait，就会立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果有这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回。如果没有这样一个子进程，wait就会一直阻塞在这里直到有一个出现为止。
这里的status保存的是子进程退出时的一些状态，wait函数返回值是子进程的进程ID。
```

```c
fork():
父进程调用fork，就会复制一份主程序，即创建主进程的子进程。在程序运行的过程中，一次fork返回两次值，在父进程中返回新创建的子进程的进程ID，在子进程中返回0，根据返回值可以判断此时程序在哪个进程中。

perror():
将上一个函数的发生错误的原因输出到标准错误
```

```c
exec():不新开一个子进程，直接用新的进程去代替原来的程序运行，运行完毕后不回到原先的程序中，这个新的进程和原来的进程有相同的PID。
system():调用shell执行命令，system=fork+exec+waitpid，执行完毕后回到原先的程序中去，继续执行下面的部分。
```

---

### 初步想法

```bash
在前台程序中需要完成的功能：
1.接受输入
2.对输入进行转换（通过字典或者哈希表实现）
3.通过fork和execl调起后台程序
4.创建消息队列和命名管道
5.将转换后的命令传入消息队列
6.通过命名管道获取结果并显示在终端
在后台程序中需要完成的功能：
1.通过消息队列接收转换后的命令
2.执行具体的命令（popen）
3.将执行的结果传入命名管道
结束命令：
1.前台输入exit
2.后台接受指令退出进程
3.前台接收信号并退出
```

### 几个模块

```ba
1.forend
目前大体框架已经完成，还差消息队列和调起后台程序。
2.cdBackend
后台程序执行了，前台程序怎么进入对应的目录？
3.lsBackend
完成
4.mvBackend
完成
5.mv2Backend
完成
6.rmBackend
完成
7.exitBackend
完成
```

















